'use strict';

const dic = require('./dictionary')
var words = ["applicant","apprehensive","aptitude","associate","bilingual","broad","candidate","certification","commensurate","confidence","consultant","degree","eligible","employment","entitle","get through","highly","increment","lag","managerial","match","meet","minimum","occupation","opening","otherwise","paycheck","payroll","pension","probationary","professional","proficiency","prospective","qualified","recruit","reference","regardless of","requirement","resume","wage","abolish","access","accordance","according to","accuse","adhere","approval","at all time","attire","attorney","authorize","circumscribe","code","comply","concern","custody","effect","enforce","exception","form","fraud","habit","immediately","infringement","legislation","legitimate","litigation","observance","petition","policy","procedure","prohibit","prosecute","refrain","regulation","restrict","severely","standard","thoroughly","violate","accustomed","acquaint","affiliate","attendance","check","colleague","concentrate","condense","conglomerate","convey","corporation","delegate","demanding","directly","division","efficiently","electronically","extension","follow up on","impending","in one's absence","in writing","instruct","involved","manage","memorandum","notify","on one's own","oversee","proprietor","quarterly","release","remind","request","revision","submit","subordinate","subsidiary","supervision","translation","accomplish","adjust","agree","aspiration","assign","assist","assume","combined","conduct","confidential","contrary","coordinate","count on","creditable","direct","disturbing","draw on","duplicate","eminent","endeavor","engage","execute","foster","friction","get along with","hardly","insubordinate","intention","lax","malign","neutrality","occasionally","personnel","procrastinate","respectful","respective","responsible","routinely","subsequent","transform","undertake","voluntarily","widely","accessible","accidentally","advisable","aggravate","announcement","apparently","aspect","aware","compliance","concerned","contingency","demonstrate","divide","embrace","evacuate","expertise","extended","face","failure","feedback","follow","implement","inform","instead of","interruption","make sure","matter","outstanding","privilege","promptly","realistically","remainder","rush","sign out","sophisticated","speak","take on","timely","trigger","violation","abate","adversity","ailing","assert","boost","brisk","collapse","commerce","consequence","depression","deteriorate","dramatically","dwindle","economical","entail","fairly","fall","flourish","impede","implication","indicator","industrial","lead","likely","overall","promising","prospect","prosperity","rapidly","ratio","remain","skyrocket","slowdown","soar","stagnant","supplement","thrive","unstable","volatile","wane","admission","advocate","alumni","anonymous","appear","beneficial","care of","celebrity","censorship","collection","come in +서수","contestant","contributor","current","defy","donation","edition","enlightening","enthusiastically","exhibition","fascinating","have yet to do","improvise","informative","issue","lend","live","local","matinee","memoirs","municipal","must-see","note","out of print","periodical","popular","present","publication","showing","subscription","transferable","upcoming","variety","affect","analysis","claim","closely","comparison","competition","consecutive","consistently","consolidate","contend","demand","do one's utmost","effective","especially","examine","expand","expectation","extremely","focus","gap","gauge","impact","intervention","jeopardize","modestly","momentum","monopoly","mounting","perception","persistent","probable","raise","randomly","reflective","respondent","seasonal","segment","survey","tool","adopt","advantage","advertisement","advise","aggressively","aim","attract","await","cater","confront","consumer","creative","customer","deliberate","diversify","effort","endorse","experiment","favorably","feasible","fortify","forward","incentive","indicate","influence","instantly","introduce","largely","less","majority","marginal","mastermind","means","necessarily","need","repeatedly","strategy","affordable","alter","apparel","apply","area","auction","authentic","benefit","carefully","charge","delivery","description","dilute","equivalent","exactly","exclusively","exquisite","fit","installment","lately","merchandise","method","notice","offer","officially","price","purchase","readily","receipt","redeemable","refund","relatively","scent","sturdy","tax","thrifty","valid","value","voucher","warranty","assemble","attribute","automate","capable","capacity","carelessly","chemical","coming","comparable","damaged","device","discontinue","efficiency","equipment","evidently","fabricate","facility","fill","finished","halt","launch","material","operate","operational","place","power","precaution","prevent","processing","procurement","produce","properly","protective","quota","safety","separately","specification","stage","tolerance","utilize","absolute","accurate","advance","allow","appearance","bewildering","broaden","compatible","complement","concurrently","control","corrosion","development","devise","disruption","durable","envision","feature","following","grant","hold","improve","increasingly","indication","innovative","inspect","inspiration","interpretation","manufacturer","obsolete","patent","patronize","quality","reliable","research","revolutionary","sleek","state-of-the-art","streamline","sufficiently","superior","technical","vulnerable","apologize","appropriately","argumentative","blemish","cause","commitment","complaint","complete","compliment","confident","courteous","critical","deal","defective","disclose","escort","evaluation","fix","for free","further","genuine","guarantee","hesitate","inconvenience","infuriate","inquire","insert","mistakenly","notification","politely","rebate","replace","respond","return","satisfaction","seriously","specific","unwavering","accumulate","allowance","approximately","attraction","away","baggage","beforehand","board","brochure","customs","declare","depart","destination","diverse","dramatic","duty","embassy","emergency","exotic","fill out/in","hospitality","indulge","international","itinerary","jet lag","laundry","locate","missing","overhead","precisely","prior to","proximity","remittance","round trip","seating","superb","swap","touch down","tour","unavailable","unique","unlimited","agreement","alliance","annotated","annulment","arbitration","bid","challenging","collaborate","compromise","contract","cooperatively","deadlock","dispute","embark","expire","foundation","impartially","imperative","impression","initially","mediation","moderator","modify","narrow","negotiation","opposing","originally","preamble","proceed","proposal","provision","renew","review","rigid","settle","solicit","stipulation","surely","term","terminate","acclaim","antitrust","assure","at the latest","attain","bulk","capitalize on","commodity","completely","confirmation","consignment","contact","cultivation","dealer","depot","diminish","distribute","diversified","do business with","encompass","engrave","enviable","inevitable","inventory","invoice","keep track of","order","provide","quote","refuse","represent","retail","satisfactory","selection","short","shortly","stock","subject","supply","temporarily","unable","accelerate","acknowledge","address","adequately","affix","attach","bilateral","by hand","carton","caution","convenience","correspondence","courier","deliver","detach","efficient","embargo","enact","enclose","ensure","envelope","expedite","fragile","handle","impose","inaugurate","incorrect","oblige","particularly","perishable","postage","recipient","reciprocal","remarkable","retaliation","shipment","step","surplus","accommodate","agreeably","ahead","amenity","assorted","atmosphere","available","belongings","check in","chef","choice","compensate","complication","complimentary","confirm","connoisseur","container","conveniently","cuisine","dignitary","elegant","entirely","extensive","flavor","forfeit","freshness","indigenous","make","occupancy","polish","rate","reception","recipe","reservation","retain","stir","taste","utensil","anticipate","decline","decrease","demoralize","depend","deviate","disappointing","encouraging","exceed","factor","figure","growth","illustrate","impressive","inaccurate","increase","incur","indicative","infusion","make up for","markedly","meagerly","minimally","offset","percentage","production","profit","projection","proportion","recent","reduce","regular","representative","revenue","sale","significantly","slightly","substantial","summarize","tend","unusually","accountant","accurately","allocate","amend","audit","barely","budget","calculate","committee","compare","curtail","deduct","deficient","deficit","discrepancy","excess","exempt","expenditure","financial","fiscal","fund","generate","in the red","incidental","inconsistency","inflation","ledger","liability","liable","monetary","outlay","overcome","preferred","recently","reimburse","rigorously","spend","stringently","substantially","total","turnover","worth","accept","acquire","active","allegedly","announce","asset","authority","clout","considerable","contingent","contribute","dedicated","emerge","enhance","establish","established","expansion","force","foresee","go through","independent","informed","initiate","interested","liquidate","merge","premier","productivity","progressive","relocate","reveal","run","simultaneously","stance","strategic","strike","struggle","subsidize","surpass","takeover","uncertain","waive","aid","chance","clear","conserve","contaminate","continually","damage","deciduous","deplete","disaster","discharge","dispose","drought","ecology","emission","endangered","environmental","extinction","flood","forecast","fumes","habitat","ideal","inclement","inflict","meteorological","migration","mining","occur","organization","pollutant","precipitation","prominent","purify","recycling","resource","sewage","shower","solution","southern","vague","waste","account","accrue","amount","balance","belatedly","bill","bounce","cash","collateral","confiscate","convert","counterfeit","curb","delinquent","deposit","deterrent","document","due","expect","heavily","identification","in common","interest","investigation","loan","lower","mortgage","overdue","owe","owing to","payable","personal","previously","regrettably","relation","scrutinize","statement","study","sustain","transaction","turn down","unexpected","withdrawal","bond","cautiously","confusion","consider","controversy","depreciation","devastate","dividend","entrepreneur","eventually","foreseeable","increasing","inherently","innate","insecure","investor","justify","legacy","lucrative","manipulation","nearly","on behalf of","out look","outweigh","pitfall","plummet","portfolio","possible","prevalent","property","rapid","shareholder","solely","somewhat","speculation","stability","unbiased","unprecedented","unwillingness","yield","alleviate","alternative","average","bear","cite","clearly","commute","conform","congestion","designated","detailed","detour","divert","emphatic","equip","expense","fare","fine","fuel","gratuity","malfunction","motivate","normal","obstruct","obtain","official","opportunity","opposite","opposition","permit","principal","prominently","reserved","reverse","securely","simply","thereafter","tow","transportation","vehicle","abbreviate","adjourn","agenda","attention","brief","coherent","comment","confine","consensus","constraint","constructive","convene","convince","coordination","defer","differ","discuss","disperse","distract","easy","elaborate","emphasis","faction","give","hold back","illegible","irrelevant","judge","mention","object","opponent","organize","persuasive","preside","press","presumably","refute","succinct","suggestion","unanimous","understanding","uphold","usually","annual","arise","attend","attendee","chronological","commence","conference","conjunction","customize","discriminate","earn","enroll","entry","exhibitor","existing","exploit","function","give in","honor","host","include","labor","leave","lecture","morale","objective","participant","purpose","refer","regard","registration","reimbursement","require","respectfully","responsibility","result","schedule","tentative","union","unused","above all","appoint","appraisal","appreciation","award","characteristic","congratulate","cordially","dedication","delicate","early","encouragement","evaluate","exceptional","incompetent","lay off","level","nomination","participation","performance","praise","predecessor","predict","progress","promote","put in for","radically","reorganize","resignation","reward","search","serve","skilled","stand in for","strictly","transfer","undoubtedly","adjacent","annex","arrange","community","complex","compulsory","consist","construction","currently","delay","demolish","densely","describe","desirable","district","drape","finally","furnished","install","insulation","interfere","location","maintain","numerous","overprice","permanent","premises","presently","renewal","renovation","repair","residence","restore","spacious","structure","tenant","unoccupied","urban","utility","antibiotic","asthma","checkup","chronic","combination","comprehensive","conscious","coverage","deprivation","deter","diagnosis","dose","duration","eliminate","eradicate","exposure","fatigue","forbid","health","immune","induce","inhalation","insurance","join","medicinal","nutrition","periodically","pharmaceutical","physician","premium","prescribe","prevention","prolonged","reaction","recommend","recovery","relieve","remedy","robust","susceptible","symptom"];

const wordsDetail = require('./wordsDetail.json');
const AWS = require('aws-sdk');
const docClient = new AWS.DynamoDB.DocumentClient({region: 'us-east-1'});

var VERIFY_TOKEN = "my_awesome_token";
var https = require('https');
var PAGE_ACCESS_TOKEN = "EAAboQgaMNgcBAJRu6ZCyCPBY3tX5Fql2dqVEwQ8ZBHr5srwZBOBqcW84ZBzPKnRoTBaHZC2dW900czjLqvI8iAQm3xJYyZCrCFdKXnnL7NcTJaO5zJZCZAWSmwmyP4ZBXoFEOoWCM4WRf3RsIeBsvn49mjoMvZCrlqpoYj1CMyd1SnHQZDZD";
exports.intents = (event, context, callback) => {
  console.log("Webhook received event");  
  console.log("event.body: ", event.body);
  // process GET request
  if(event.queryStringParameters){
    var queryParams = event.queryStringParameters;
 
    var rVerifyToken = queryParams['hub.verify_token']
 
    if (rVerifyToken === VERIFY_TOKEN) {
      var challenge = queryParams['hub.challenge']
      
      var response = {
        'body': parseInt(challenge),
        'statusCode': 200
      };
      
      callback(null, response);
    }else{
      var response = {
        'body': 'Error, wrong validation token',
        'statusCode': 422
      };
      
      callback(null, response);
    }
  
  // process POST request
  } else {
    var data = JSON.parse(event.body);
    // Make sure this is a page subscription
    if (data.object === 'page') {
    // Iterate over each entry - there may be multiple if batched
    data.entry.forEach(function(entry) {
      var pageID = entry.id;
      var timeOfEvent = entry.time;
      // Iterate over each messaging event
      entry.messaging.forEach(function(msg) {
        //데이터베이스에서 userData 읽기
        var params = {
          TableName: 'wordBot',
          Key: {
            UserId: Number(msg.sender.id)
          }
        }
        docClient.get(params).promise()
        .then((data) => {
          // console.log('첫번째 프로미스 data', data);
          if (data.Item && data.Item.userData) {
            return data;
          } else {
            var userData = {
              study: {
                currentWordIndex: 0
              },
              test: {
                currentWordIndex: 0
              }
            }
            var params = {
              TableName:'wordBot',
              Key:{
                "UserId": Number(msg.sender.id)
              },
              UpdateExpression: "set userData=:a",
              ExpressionAttributeValues:{
                  ":a":userData
              },
              ReturnValues:"UPDATED_NEW"
            };
            console.log("Updating the item...");
            return docClient.update(params).promise().then((data) => {
              var params = {
                TableName: 'wordBot',
                Key: {
                  UserId: Number(msg.sender.id)
                }
              }
              return docClient.get(params).promise().then((data) => {
                return data;
              })
            });
          }
        })//end of first promist
        .then((data) => {
        //두번째 프로미스 시작
          //console.log('두번째 프로미스 체인 data: ', data);
          var studyIndex = data.Item.userData.study.currentWordIndex;
          var testIndex = data.Item.userData.test.currentWordIndex;

          if (msg.read) {
            console.log(`
              유저가 ${msg.read.watermark} 메시지 읽음
              msg: ${JSON.stringify(msg)}`);
          } else if (msg.delivery) {
            console.log(`
              ${msg.delivery.watermark} 딜리버리 됨
              msg: ${JSON.stringify(msg)}`);
          } else if (msg.message) {
            if (msg.message['is_echo'] === true) {
              console.log(`
                ${msg.message.text}에 대한 에코
                msg: ${JSON.stringify(msg)}`);
            } else {
              console.log(`
                유저가 메시지 보냄
                유저: ${msg.sender.id}
                메시지: ${msg.message.text}
                msg: ${JSON.stringify(msg)}`)
              //따봉 처리
              if (msg.message.sticker_id) {
                if (msg.message.sticker_id === 369239263222822) {
                  handleThumbsUp(msg.sender.id);
                } else if (msg.message.sticker_id === 369239343222814 || msg.message.sticker_id === 369239383222810) {
                  handleBigThumbsUp(msg.sender.id);
                } else {
                  sendSimpleTextMessage(msg.sender.id, "뭔말인지 모르겠다. 공부나 하자");
                  setTimeout(() => {
                    sendSimpleTextMessage(msg.sender.id, "나한테 '?'를 보내면");
                  }, 1000);
                  setTimeout(() => {
                    sendSimpleTextMessage(msg.sender.id, "내가 뭘 할 수 있는지 알려줄께");
                  }, 2000);
                }
                //도움말 처리
              } else if (msg.message.text === "?") {
                handleQuestionMark(msg.sender.id);
              } else if (msg.message.text.indexOf('복습') !== -1 || msg.message.text.indexOf('ㅂㅅ') !== -1) {
                // changeMode(msg.sender.id, 'review');
                // sendSimpleTextMessage(msg.sender.id, '자 틀렸던 단어 복습을 시작하자!');
                // sendQuestionMessage(msg.sender.id);
                changeMode(msg.sender.id, 'review');
                var params = {
                  TableName: 'wordBot',
                  Key: {
                    UserId: Number(msg.sender.id)
                  }
                }
                docClient.get(params).promise()
                .then((data) => {
                  var timeNow = Date.now();
                  var reviewCollection = data.Item.review.filter((element) => {
                    return element.date < timeNow;
                  });
                  if (reviewCollection.length === 0) {
                    sendSimpleTextMessage(msg.sender.id, `지금 복습할게 전혀 없네^^`);
                  } else {
                    sendSimpleTextMessage(msg.sender.id, `지금 복습할게 ${reviewCollection.length}개 있네`);
                    // setTimeout(() => {
                    //   quickReply(msg.sender.id, '지금 복습 할래?', '그래', '나중에');
                    // }, 1000);
                    setTimeout(() => {
                      sendSimpleTextMessage(msg.sender.id, `복습 시작한다.`);
                    }, 1000);
                    setTimeout(() => {
                      sendQuestionMessage(msg.sender.id, reviewCollection[0].word, 'review');
                    }, 2000);
                  }
                });
              } else if (msg.message.text.indexOf('공부') !== -1 || msg.message.text.indexOf('ㄱㅂ') !== -1) {
                changeMode(msg.sender.id, 'test');
                sendSimpleTextMessage(msg.sender.id, '자 공부를 시작하자!');
                setTimeout(() => {
                  sendQuestionMessage(msg.sender.id, words[testIndex], 'test');
                }, 1000);
              } else if (msg.message.text.indexOf('진도') !== -1 || msg.message.text.indexOf('ㅈㄷ') !== -1) {
                var params = {
                  TableName: 'wordBot',
                  Key: {
                    UserId: Number(msg.sender.id)
                  }
                }
                docClient.get(params, function(err, data) { 
                  if (err) {
                    console.log(err);
                  } else {
                    console.log(data);
                    var history = data.Item.history;
                    var arrangedData = {
                      wrongWords: {},
                      rightCnt: 0,
                      wrongCnt: 0
                    };
                    history.forEach((element) => {
                      if (element.right) {
                        arrangedData.rightCnt++;
                      } else {
                        arrangedData.wrongCnt++;
                        if (arrangedData.wrongWords[element.word]) {
                          arrangedData.wrongWords[element.word]++;
                        } else {
                          arrangedData.wrongWords[element.word] = 1;
                        }
                      }
                    });
                    var wrongWordsSentence = '';
                    for (var key in arrangedData.wrongWords) {
                      wrongWordsSentence += key + ', ';
                    }
                    var reviewCollection = data.Item.review.filter((element) => {
                      return element.date < timeNow;
                    });
                    sendSimpleTextMessage(msg.sender.id, `총 1233 단어 중 ${data.Item.userData.test.currentWordIndex}번째 단어 학습 중이고`);
                    setTimeout(() => {
                      sendSimpleTextMessage(msg.sender.id, `지금 복습할게 ${reviewCollection.length}개 있네`);
                    }, 2000);
                    setTimeout(() => {
                      sendSimpleTextMessage(msg.sender.id, `수고했어`);
                    }, 4000);
                    setTimeout(() => {
                      sendSimpleTextMessage(msg.sender.id, `틀렸던 단어들 한번 보여줄께`);
                    }, 6000);
                    setTimeout(() => {
                      sendSimpleTextMessage(msg.sender.id, wrongWordsSentence);
                    }, 8000);
                    setTimeout(() => {
                      sendSimpleTextMessage(msg.sender.id, '복습 한번 하고가~');
                    }, 10000);
                  }
                })
              } else if (msg.message.text.indexOf('힌트') !== -1 || msg.message.text.indexOf('ㅎㅌ') !== -1) {
                quickReply(msg.sender.id, '원하는 힌트를 아래서 골라봐', '예문', '유의어', '어원');
              } else if (msg.message.text.indexOf('예문') !== -1 || msg.message.text.indexOf('ㅇㅁ') !== -1) {
                getLastCheckedWord(msg.sender.id)
                .then((data) => {
                  console.log('data.Item.lastWord(from promise): ', data.Item.lastWord);
                  var recentQuestion = data.Item.lastWord;
                  var examples = getExamples(recentQuestion);
                  if (examples.length === 0) {
                    sendSimpleTextMessage(msg.sender.id, '앗 예문이 하나도 없네ㅋㅋ. 미안.');
                    setTimeout(() => {
                      quickReply(msg.sender.id, '다른거 골라봐', '예문', '유의어', '어원');
                    }, 1500);
                  } else {
                    examples.forEach(function(example) {
                      sendSimpleTextMessage(msg.sender.id, example);
                    });
                  }
                });
              } else if (msg.message.text.indexOf('유의어') !== -1 || msg.message.text.indexOf('ㅇㅇㅇ') !== -1) {
                getLastCheckedWord(msg.sender.id)
                .then((data) => {
                  console.log('data.Item.lastWord(from promise): ', data.Item.lastWord);
                  var recentQuestion = data.Item.lastWord;
                  var synonyms = getSynonyms(recentQuestion);
                  if (synonyms.length === 0) {
                    sendSimpleTextMessage(msg.sender.id, '앗 유의어가 하나도 없네ㅋㅋ. 미안.');
                    setTimeout(() => {
                      quickReply(msg.sender.id, '다른거 골라봐');
                    }, 1500);
                  } else {
                    synonyms.forEach(function(example) {
                      sendSimpleTextMessage(msg.sender.id, example);
                    });
                  }
                });
              } else if (msg.message.text.indexOf('어원') !== -1 || msg.message.text.indexOf('ㅇㅇ') !== -1) {
                getLastCheckedWord(msg.sender.id)
                .then((data) => {
                  console.log('data.Item.lastWord(from promise): ', data.Item.lastWord);
                  var recentQuestion = data.Item.lastWord;
                  var derivation = getDerivation(recentQuestion);
                  if (derivation.length === 0) {
                    sendSimpleTextMessage(msg.sender.id, '앗 어원이 하나도 없네ㅋㅋ. 미안.');
                    setTimeout(() => {
                      quickReply(msg.sender.id, '다른거 골라봐');
                    }, 1500);
                  } else {
                    derivation.forEach(function(example) {
                      sendSimpleTextMessage(msg.sender.id, example);
                    });
                  }
                });
              } else if (msg.message.text.indexOf('관계') !== -1 || msg.message.text.indexOf('ㄱㄱ') !== -1) {
                getLastCheckedWord(msg.sender.id)
                .then((data) => {
                  console.log('data.Item.lastWord(from promise): ', data.Item.lastWord);
                  var recentQuestion = data.Item.lastWord;
                  var hierarchy = getHierarchy(recentQuestion);
                  var messageTime = 500;
                  var listTime = 1500;
                  for (var key in hierarchy) {
                    console.log('hierarchy loop', key);
                    var text;
                    if (hierarchy[key].length === 0) {
                      continue;
                    } else {
                      if (key === 'partOf') {
                        text = '는 아래 단어들의 부분이야';
                      } else if (key === 'typeOf') {
                        text = '는 아래 단어들의 한 타입이야';
                      } else if (key === 'hasTypes') {
                        text = '는 아래와 같은 타입들을 가지고 있어';
                      } else if (key === 'substanceOf') {
                        text = '는 아래 단어의 구성 성분이야';
                      }
                      setTimeout(() => {
                        sendSimpleTextMessage(msg.sender.id, recentQuestion + text);
                      }, messageTime);
                      setTimeout(() => {
                        sendSimpleTextMessage(msg.sender.id, hierarchy[key].join(', '));
                      }, listTime);
                      messageTime += 1000;
                      listTime += 1000;
                    }
                  }
                });
              } else if (msg.message.quick_reply) {
                var whatUserWant = msg.message.quick_reply.payload;
                getLastCheckedWord(msg.sender.id);
              } else {
                sendSimpleTextMessage(msg.sender.id, "뭔말인지 모르겠다. 공부나 하자");
                setTimeout(() => {
                  sendSimpleTextMessage(msg.sender.id, "나한테 '?'를 보내면");
                }, 1000);
                setTimeout(() => {
                  sendSimpleTextMessage(msg.sender.id, "내가 뭘 할 수 있는지 알려줄께");
                }, 2000);
              }
            }
          } else if (msg.postback) {
            console.log(`
              유저가 답을 선택함
              유저: ${msg.sender.id}
              메시지: ${msg.postback.payload}
              msg: ${msg}`)
            receivedPayload(msg, data.Item);
          } else {
            console.log(`Webhook received unknown event
              event.body: ${event.body}`);
          }
        //두번째 프로미스 끝
        })
        .catch((err) => {
          console.log("Promise Rejected");
          console.log(err);
        })
      });
    });
    
    }
    // Assume all went well.
    //
    // You must send back a 200, within 20 seconds, to let us know
    // you've successfully received the callback. Otherwise, the request
    // will time out and we will keep trying to resend.
    var response = {
      'body': "ok",
      'statusCode': 200
    };
      
    callback(null, response);
  }
}

function getExamples(word) {
  var recentQuestion = word
  var examples = [];
  wordsDetail[recentQuestion].forEach(function(element) {
    if (element.examples) {
      element.examples.forEach(function(sentence) {
        examples.push(sentence);
      })
    }
  });
  return examples;
};

function getHierarchy(word) {
  var result = {
    partOf: [],
    typeOf: [],
    hasTypes: []
  }
  wordsDetail[word].forEach(function(element) {
    if (element.partOf) {
      element.partOf.forEach(function(word) {
        result.partOf.push(word);
      })
    }
  });
  wordsDetail[word].forEach(function(element) {
    if (element.typeOf) {
      element.typeOf.forEach(function(word) {
        result.typeOf.push(word);
      })
    }
  });
  wordsDetail[word].forEach(function(element) {
    if (element.hasTypes) {
      element.hasTypes.forEach(function(word) {
        result.hasTypes.push(word);
      })
    }
  });
  return result;
}

function getDerivation(word) {
  var result = [];
  wordsDetail[word].forEach(function(element) {
    if (element.derivation) {
      element.derivation.forEach(function(derivation) {
        result.push(derivation);
      })
    }
  });  
  return result;
}

function getSynonyms(word) {
  var result = [];
  wordsDetail[word].forEach(function(element) {
    if (element.synonyms) {
      element.synonyms.forEach(function(synonym) {
        result.push(synonym);
      })
    }
  });  
  return result;
}

function getLastCheckedWord(senderId) {
  var params = {
    TableName: 'wordBot',
    Key: {
      UserId: Number(senderId)
    }
  }
  return docClient.get(params).promise();
}

function receivedMessage(event) {
  var senderID = event.sender.id;
  var recipientID = event.recipient.id;
  var timeOfMessage = event.timestamp;
  var message = event.message;
  // console.log("Received message for user %d and page %d at %d with message:", senderID, recipientID, timeOfMessage);
  // console.log(JSON.stringify(message));
  var messageId = message.mid;
  var messageText = message.text;
  var messageAttachments = message.attachments;

  if (messageText) {
    // If we receive a text message, check to see if it matches a keyword
    // and send back the example. Otherwise, just echo the text we received.
    switch (messageText) {
      case 'generic':
        //sendGenericMessage(senderID);
        break;
      default:
        sendQuestionMessage(senderID, messageText);
    }
  } else if (messageAttachments) {
    sendQuestionMessage(senderID, "Message with attachment received");
  }
}

function receivedPayload(event, Item) {
  console.log(`receivedPayload
    ${JSON.stringify(event)}`);
  var senderID = event.sender.id;
  var recipientID = event.recipient.id;
  var timeOfMessage = event.timestamp;
  var payload = event.postback.payload.split('|');
  var questionWord = payload[0];
  var answer = payload[1];
  var questionDate = payload[2];
  var questionMode = payload[3];
  var reviewDate = payload[4];

  if (payload[3] === 'test') {
    if (Item.studyMode === 'test') {
      var params = {
          TableName:'wordBot',
          Key:{
            "UserId": Number(senderID)
          },
          UpdateExpression: "set userData.test.currentWordIndex = userData.test.currentWordIndex + :val",
          ExpressionAttributeValues:{
              ":val":1
          },
          ReturnValues:"UPDATED_NEW"
      };
    } else if (Item.studyMode === 'study') {
      var params = {
          TableName:'wordBot',
          Key:{
            "UserId": Number(senderID)
          },
          UpdateExpression: "set userData.study.currentWordIndex = userData.study.currentWordIndex + :val",
          ExpressionAttributeValues:{
              ":val":1
          },
          ReturnValues:"UPDATED_NEW"
      };
    }
    console.log("Updating the item...");
    docClient.update(params, function(err, data) {
      if (err) {
        console.log("Unable to update item. Error JSON:", JSON.stringify(err, null, 2));
      } else {
        console.log("userData.study.currentWordIndex = userData.study.currentWordIndex + :val succeeded");
        // console.log("UpdateItem succeeded:", JSON.stringify(data, null, 2));
      }
    });
    console.log(typeof Item.userData.test.currentWordIndex, Item.userData.test.currentWordIndex );
    var index = Item.userData.test.currentWordIndex + 1;
    console.log('질문을 위한 index: ', index);

    //만약 답이 맞으면 맞았다고 말하고 0.5초 후 다음 문제
    if (dic[questionWord] === answer) {
      sendSimpleTextMessage(senderID, compliment());
      updateHistory(senderID, questionWord, true);
      setTimeout(() => {
        sendQuestionMessage(senderID, words[index], Item.studyMode);
      }, 1000);
    } else { //틀렸으면 틀렸다고 말해주고 잠시 생각해보라 하고 3초 후 답 주고 1초 후 다음 문제

      sendSimpleTextMessage(senderID, sorry());
      updateHistory(senderID, questionWord, false);
      var reviewTime = Date.now() + 1000 * 60 * 1; //1분
      putReview(senderID, questionWord, false, reviewTime);
      setTimeout(() => {
        sendSimpleTextMessage(senderID, `${questionWord} : ${dic[questionWord]}`);
      }, 1000);
      setTimeout(() => {
        sendQuestionMessage(senderID, words[index], Item.studyMode);
      }, 3000);
    }
  } else if (payload[3] === '     ') {
    //해당 엘리먼트를 리뷰에서 지우고
    var params = {
        TableName:'wordBot',
        Key:{
          "UserId": Number(senderID)
        },
        UpdateExpression: "REMOVE review[0]",
        ReturnValues:"UPDATED_NEW"
    };
    docClient.update(params).promise()
    .then((data) => {
      var params = {
        TableName: 'wordBot',
        Key: {
          UserId: Number(senderID)
        }
      }
      docClient.get(params).promise()
      .then((data) => {
        var timeNow = Date.now();
        var reviewCollection = data.Item.review.filter((element) => {
          return element.date < timeNow;
        });
        //맞았으면 
        if (dic[questionWord] === answer) {
          var reviewTime = Date.now() + 1000 * 60 * 10; //1분
          putReview(senderID, questionWord, true, reviewTime);
          sendSimpleTextMessage(senderID, compliment());
          if (reviewCollection.length === 0) {
            setTimeout(() => {
              sendSimpleTextMessage(senderID, `복습 끝! 축하축하!`);
            }, 1000);
          } else {
            setTimeout(() => {
              sendSimpleTextMessage(senderID, `다음꺼 간다`);
            }, 1000);
            console.log('리뷰 페이로드에서: data.Item', data.Item);
            setTimeout(() => {
              sendQuestionMessage(senderID, reviewCollection[0].word, 'review');
            }, 2000);
          }
        //틀렸으면
        } else {
          sendSimpleTextMessage(senderID, '또 틀렸네');
          // updateHistory(senderID, questionWord, false);
          var reviewTime = Date.now() + 1000 * 60 * 1; //1분
          setTimeout(() => {
            sendSimpleTextMessage(senderID, `${questionWord} : ${dic[questionWord]}`);
          }, 1000);
          if (reviewCollection.length === 0) {
            setTimeout(() => {
              sendSimpleTextMessage(senderID, `복습 끝! 축하축하!`);
            }, 3000);
          } else {
            setTimeout(() => {
              sendQuestionMessage(senderID, reviewCollection[0].word, 'review');
            }, 3000);
          }
          putReview(senderID, questionWord, false, reviewTime);
        }
      });
    })

  } else {
    console.log('테스트도 아니고 리뷰도 아닌 이상한 페이로드가 들어왔네?');
    console.log(`event: ${JSON.stringify(event)}`);
  }
}

function updateHistory(senderID, questionWord, rightOrWrong) {
  var reviewTime;

  var params = {
      TableName:'wordBot',
      Key:{
        "UserId": Number(senderID)
      },
      UpdateExpression: 'set #history = list_append(if_not_exists(#history, :empty_list), :data)',
      ExpressionAttributeNames: {
        '#history': 'history'
      },
      ExpressionAttributeValues: {
        ':data': [{
            word: questionWord,
            right: rightOrWrong,
            date: Date.now()
          }],
        ':empty_list': []
      },
      ReturnValues:"UPDATED_NEW"
  };


  console.log("Updating the item...");
  docClient.update(params, function(err, data) {
    if (err) {
      console.log("Unable to update item. Error JSON:", JSON.stringify(err, null, 2));
    } else {
      console.log("UpdateItem succeeded");
      // console.log("UpdateItem succeeded:", JSON.stringify(data, null, 2));
    }
  });
}

function putReview(senderID, questionWord, rightOrWrong, reviewTime) {
  var params = {
      TableName:'wordBot',
      Key:{
        "UserId": Number(senderID)
      },
      UpdateExpression: 'set #review = list_append(if_not_exists(#review, :empty_list), :data)',
      ExpressionAttributeNames: {
        '#review': 'review'
      },
      ExpressionAttributeValues: {
        ':data': [{
            word: questionWord,
            right: rightOrWrong,
            date: reviewTime
          }],
        ':empty_list': []
      },
      ReturnValues:"UPDATED_NEW"
  };

  console.log("Updating the item...");
  docClient.update(params, function(err, data) {
    if (err) {
      console.log("Unable to update item. Error JSON:", JSON.stringify(err, null, 2));
    } else {
      console.log("UpdateItem succeeded");
      // console.log("UpdateItem succeeded:", JSON.stringify(data, null, 2));
    }
  });
}

function changeMode(recipientId, mode) {
  var params = {
      TableName:'wordBot',
      Key:{
        "UserId": Number(recipientId)
      },
      UpdateExpression: "set studyMode=:a",
      ExpressionAttributeValues:{
          ":a":mode
      },
      ReturnValues:"UPDATED_NEW"
  };

  console.log("Updating the item...(changeMode)");
  docClient.update(params, function(err, data) {
    if (err) {
      console.log("Unable to update item. Error JSON:", JSON.stringify(err, null, 2));
    } else {
      console.log("UpdateItem succeeded");
      // console.log("UpdateItem succeeded:", JSON.stringify(data, null, 2));
    }
  });
}

function compliment() {
  var sentences = ["잘했어요. 짝짝짝! 다음 단어!", "굿!", "굿 잡!", "좋아요.", "잘했어요.", "참 잘했어요", "훌륭해요", "대단해요", "놀랍네요", "혹시 천재?", "님 최고!", "잘한다 잘한다 잘한다!", "짱짱맨!", "아이큐가 150?", "그레이트!", "퍼팩트!", "킹왕짱!", "굳뜨!"];
  var randomIndex = Math.floor(Math.random() * sentences.length);
  return sentences[randomIndex];
}

function sorry() {
  var sentences = ['틀렸어요 ㅜㅜ', '틀렸네ㅜㅜ', '아닌데...', '틀릴 수도 있지. 안그래?', '틀렸다. 기억하자!', '앗 틀렸다!'];
  var randomIndex = Math.floor(Math.random() * sentences.length);
  return sentences[randomIndex];
}

function pick() {
  var sentences = ['골라!', '다음 중 뭘까?', '빨리 골라!', '찍지 말고 골라!', '모르겠으면 힌트 외쳐!', '답은?'];
  var randomIndex = Math.floor(Math.random() * sentences.length);
  return sentences[randomIndex];
}

function sendSimpleTextMessage(recipientId, messageText) {
  var messageData = {
    recipient: {
      id: recipientId
    },
    message: {
      text: messageText
    }
  };
  callSendAPI(messageData);
}

function quickReply(recipientId, messageText) {
  var quick_replies = [];
  for (var i = 2; i < arguments.length; i++) {
    var quick_reply = {
      "content_type":"text",
      "title":arguments[i],
      "payload":arguments[i]
    };
    quick_replies.push(quick_reply);
  }
  var messageData = {
    recipient: {
      id: recipientId
    },
    message: {
      "text": messageText,
      "quick_replies": quick_replies
    }
  };
  callSendAPI(messageData);
}

function sendQuestionMessage(recipientId, word, mode) {
  var messageData = {
    recipient: {
      id: recipientId
    },
    message: questionMaker(word, mode)
  };
  console.log('messageData.message.attachment.payload: ', messageData.message.attachment.payload);

  var params = {
      TableName:'wordBot',
      Key:{
        "UserId": Number(recipientId)
      },
      UpdateExpression: "set lastWord=:a",
      ExpressionAttributeValues:{
          ":a":word
      },
      ReturnValues:"UPDATED_NEW"
  };

  console.log("Updating the item...");
  docClient.update(params, function(err, data) {
    if (err) {
      console.log("Unable to update item. Error JSON:", JSON.stringify(err, null, 2));
    } else {
      console.log("UpdateItem succeeded");
      // console.log("UpdateItem succeeded:", JSON.stringify(data, null, 2));
    }
  });
  sendSimpleTextMessage(recipientId, word + "의 뜻은?");
  setTimeout(() => {
    callSendAPI(messageData);
  }, 2000);
}

function callSendAPI(messageData) {
  var body = JSON.stringify(messageData);
  var path = '/v2.6/me/messages?access_token=' + PAGE_ACCESS_TOKEN;
  var options = {
    host: "graph.facebook.com",
    path: path,
    method: 'POST',
    headers: {'Content-Type': 'application/json'}
  };
  var callback = function(response) {
    var str = ''
    response.on('data', function (chunk) {
      str += chunk;
    });
    response.on('end', function () {
 
    });
  }
  var req = https.request(options, callback);
  req.on('error', function(e) {
    console.log('problem with request: '+ e);
  });
 
  req.write(body);
  req.end();
}

function shuffle(array) {
  var m = array.length, t, i;

  // While there remain elements to shuffle…
  while (m) {

    // Pick a remaining element…
    i = Math.floor(Math.random() * m--);

    // And swap it with the current element.
    t = array[m];
    array[m] = array[i];
    array[i] = t;
  }

  return array;
}

function handleQuestionMark(recipientId) {
  sendSimpleTextMessage(recipientId, "너가");
  setTimeout(() => {
    sendSimpleTextMessage(recipientId, "'공부'라고 하면 단어 공부를 시작해");
  }, 1000);
  setTimeout(() => {
    sendSimpleTextMessage(recipientId, "'힌트'라고 하면 마지막 문제에 대한 힌트를 줘");
  }, 2000);
  setTimeout(() => {
    sendSimpleTextMessage(recipientId, "'복습'이라고 하면 지금까지 틀린 단어들 복습을 시작해");
  }, 3000);
  setTimeout(() => {
    sendSimpleTextMessage(recipientId, "'진도'라고 하면 현재 상황을 보여줘");
  }, 4000);
  setTimeout(() => {
    sendSimpleTextMessage(recipientId, "'추가기능'이라고 하면 또 다른 기능들을 알려줄께");
  }, 5000);
  setTimeout(() => {
    sendSimpleTextMessage(recipientId, "아참, 난 초성으로만 써도 알아들어^^");
  }, 5000);
}

function handleThumbsUp(recipientId) {
  sendSimpleTextMessage(recipientId, "따봉 고마워");
  setTimeout(() => {
    sendSimpleTextMessage(recipientId, "근데 큰 따봉 줄 순 없었니?");
  }, 1000);
}

function handleBigThumbsUp(recipientId) {
  sendSimpleTextMessage(recipientId, "큰 따봉 고마워");
  setTimeout(() => {
    sendSimpleTextMessage(recipientId, "근데 난 너가 공부하는게 더 좋아");
  }, 1000);
  setTimeout(() => {
    sendSimpleTextMessage(recipientId, "미안.");
  }, 2000);
} 

function questionMaker(word, mode, reviewDate) {
  var word = word || "applicant";
  var reviewDate = reviewDate || 0;
  var randomIndexTwo = Math.floor(Math.random() * words.length);
  var randomIndexThree = Math.floor(Math.random() * words.length);
  var timeNow = Date.now();
  var buttons = [
    {
      "type":"postback",
      "title":dic[word],
      "payload":word + '|' + dic[word] + '|' + timeNow + '|' + mode + '|' + reviewDate
    },
    {
      "type":"postback",
      "title":dic[words[randomIndexTwo]],
      "payload":word + '|' + dic[words[randomIndexTwo]] + '|' + timeNow + '|' + mode + '|' + reviewDate
    },
    {
      "type":"postback",
      "title":dic[words[randomIndexThree]],
      "payload":word + '|' + dic[words[randomIndexThree]] + '|' + timeNow + '|' + mode + '|' + reviewDate
    }
  ];
  var message = {
    "attachment":{
      "type":"template",
      "payload":{
        "template_type":"button",
        "text":pick(),
        "buttons":shuffle(buttons)
      }
    }
  };
  return message;
}

// function questionMaker(word, mode, reviewDate) {
//   var word = word || "applicant";
//   var reviewDate = reviewDate || 0;
//   var randomIndexTwo = Math.floor(Math.random() * words.length);
//   var randomIndexThree = Math.floor(Math.random() * words.length);
//   var timeNow = Date.now();
//   var buttons = [
//     {
//       "type": "postback",
//       "title": dic[word],
//       "payload": {
//         word: word,
//         userAnswer: dic[word],
//         rightOrWrong: true,
//         generatedTime: timeNow,
//         mode: mode,
//         reviewDate: reviewDate
//       }
//     },
//     {
//       "type":"postback",
//       "title":dic[words[randomIndexTwo]],
//       "payload": {
//         word: word,
//         userAnswer: dic[words[randomIndexTwo]],
//         rightOrWrong: true,
//         generatedTime: timeNow,
//         mode: mode,
//         reviewDate: reviewDate 
//       }
//     },
//     {
//       "type":"postback",
//       "title":dic[words[randomIndexThree]],
//       "payload": {
//         word: word,
//         userAnswer: dic[words[randomIndexTwo]],
//         rightOrWrong: true,
//         generatedTime: timeNow,
//         mode: mode,
//         reviewDate: reviewDate 
//       }
//     }
//   ];
//   var message = {
//     "attachment":{
//       "type":"template",
//       "payload":{
//         "template_type":"button",
//         "text":pick(),
//         "buttons":shuffle(buttons)
//       }
//     }
//   };
//   return message;
// }